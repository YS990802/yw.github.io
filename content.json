{"meta":{"title":"余硕","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"24中设计模式-工厂方法模式","slug":"24中设计模式-工厂方法模式","date":"2021-01-21T12:09:51.000Z","updated":"2021-01-21T12:35:39.574Z","comments":true,"path":"2021/01/21/24中设计模式-工厂方法模式/","link":"","permalink":"http://example.com/2021/01/21/24%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"123456 女娲补天的故事大家都听说过吧，今天不说这个，说女娲创造人的故事，可不是“造人”的工作，这个词被现代人滥用了。这个故事是说，女娲在补了天后，下到凡间一看，哇塞，风景太优美了，天空是湛蓝的，水是清澈的，空气是清新的，太美丽了，然后就待时间长了就有点寂寞了，没有动物，这些看的到都是静态的东西呀，怎么办？ 别忘了是神仙呀，没有办不到的事情，于是女娲就架起了八卦炉（技术术语：建立工厂）开始创建人，具体过程是这样的：先是泥巴捏，然后放八卦炉里烤，再扔到地上成长，但是意外总是会产生的： 第一次烤泥人，兹兹兹兹~~，感觉应该熟了，往地上一扔，biu~，一个白人诞生了，没烤熟！ 第二次烤泥人，兹兹兹兹兹兹兹兹~~，上次都没烤熟，这次多烤会儿，往地上一扔，嘿，熟过头了，黑人哪！ 第三次烤泥人，兹~兹~兹~，一边烤一边看着，嘿，正正好，Perfect！优品，黄色人种！【备注:RB 人不属此列】 这个过程还是比较有意思的，先看看类图：（之前在论坛上有兄弟建议加类图和源文件，以后的模式都会加上去，之前的会一个一个的补充，目的是让大家看着舒服，看着愉悦，看着就想要，就像是看色情小说一样，目标，目标而已，能不能实现就看大家给我的信心了） 那这个过程我们就用程序来表现，首先定义一个人类的总称： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package com.cbf4life; &#x2F;*** @author cbf4Life cbf4life@126.com* I&#39;m glad to share my knowledge with you all.* 定义一个人类的统称*&#x2F;public interface Human &#123; &#x2F;&#x2F;首先定义什么是人类 &#x2F;&#x2F;人是愉快的，会笑的，本来是想用smile表示，想了一下laugh更合适，好长时间没有大笑了； public void laugh(); &#x2F;&#x2F;人类还会哭，代表痛苦 public void cry(); &#x2F;&#x2F;人类会说话 public void talk(); &#125; 然后定义具体的人种： package com.cbf4life; &#x2F;*** @author cbf4Life cbf4life@126.com* I&#39;m glad to share my knowledge with you all.* 黄色人种，这个翻译的不准确，将就点吧*&#x2F;public class YellowHuman implements Human &#123; public void cry() &#123; System.out.println(&quot;黄色人种会哭&quot;); &#125; public void laugh() &#123; System.out.println(&quot;黄色人种会大笑，幸福呀！&quot;); &#125; public void talk() &#123; System.out.println(&quot;黄色人种会说话，一般说的都是双字节&quot;); &#125; &#125; 白色人种： package com.cbf4life; &#x2F;*** @author cbf4Life cbf4life@126.com* I&#39;m glad to share my knowledge with you all.* 白色人种*&#x2F;public class WhiteHuman implements Human &#123; public void cry() &#123; System.out.println(&quot;白色人种会哭&quot;); &#125; public void laugh() &#123; System.out.println(&quot;白色人种会大笑，侵略的笑声&quot;); &#125; public void talk() &#123; System.out.println(&quot;白色人种会说话，一般都是但是单字节！&quot;); &#125; &#125; 黑色人种： package com.cbf4life; &#x2F;*** @author cbf4Life cbf4life@126.com* I&#39;m glad to share my knowledge with you all.* 黑色人种，记得中学学英语，老师说black man是侮辱人的意思，不懂，没跟老外说话*&#x2F;public class BlackHuman implements Human &#123; public void cry() &#123; System.out.println(&quot;黑人会哭&quot;); &#125; public void laugh() &#123; System.out.println(&quot;黑人会笑&quot;); &#125; public void talk() &#123; System.out.println(&quot;黑人可以说话，一般人听不懂&quot;); &#125; &#125;人种也定义完毕了，那我们把八卦炉定义出来： package com.cbf4life; import java.util.List; import java.util.Random; &#x2F;*** @author cbf4Life cbf4life@126.com* I&#39;m glad to share my knowledge with you all.* 今天讲女娲造人的故事，这个故事梗概是这样的：* 很久很久以前，盘古开辟了天地，用身躯造出日月星辰、山川草木，天地一片繁华* One day，女娲下界走了一遭，哎！太寂寞，太孤独了，没个会笑的、会哭的、会说话的东东* 那怎么办呢？不用愁，女娲，神仙呀，造出来呀，然后捏泥巴，放八卦炉（后来这个成了太白金星的宝贝）中烤，于是就有了人：* 我们把这个生产人的过程用Java程序表现出来：*&#x2F;public class HumanFactory &#123; &#x2F;&#x2F;定一个烤箱，泥巴塞进去，人就出来，这个太先进了public static Human createHuman(Class c)&#123; Human human&#x3D;null; &#x2F;&#x2F;定义一个类型的人类 try &#123; human &#x3D; (Human)Class.forName(c.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; &#x2F;&#x2F;你要是不说个人种颜色的话，没法烤，要白的黑，你说话了才好烤 System.out.println(&quot;必须指定人种的颜色&quot;); &#125; catch (IllegalAccessException e) &#123; &#x2F;&#x2F;定义的人种有问题，那就烤不出来了，这是... System.out.println(&quot;人种定义错误！&quot;); &#125; catch (ClassNotFoundException e) &#123; &#x2F;&#x2F;你随便说个人种，我到哪里给你制造去？！ System.out.println(&quot;混蛋，你指定的人种找不到！&quot;); &#125; return human; &#125; &#125; 然后我们再把女娲声明出来： package com.cbf4life; &#x2F;*** @author cbf4Life cbf4life@126.com* I&#39;m glad to share my knowledge with you all.* 首先定义女娲，这真是额的神呀*&#x2F;public class NvWa &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;女娲第一次造人，试验性质，少造点，火候不足，缺陷产品 System.out.println(&quot;------------造出的第一批人是这样的：白人 -----------------&quot;); Human whiteHuman &#x3D;HumanFactory.createHuman(WhiteHuman.class); whiteHuman.cry(); whiteHuman.laugh(); whiteHuman.talk(); &#x2F;&#x2F;女娲第二次造人，火候加足点，然后又出了个次品，黑人 System.out.println(&quot;\\n\\n------------造出的第二批人是这样的：黑人-----------------&quot;); Human blackHuman &#x3D; HumanFactory.createHuman(BlackHuman.class); blackHuman.cry(); blackHuman.laugh(); blackHuman.talk(); &#x2F;&#x2F;第三批人了，这次火候掌握的正好，黄色人种（不写黄人，免得引起歧义），备注：RB人不属于此列 System.out.println(&quot;\\n\\n------------造出的第三批人是这样的：黄色人种-----------------&quot;); Human yellowHuman &#x3D; HumanFactory.createHuman(YellowHuman.class); yellowHuman.cry(); yellowHuman.laugh(); yellowHuman.talk() &#125; &#125; ​ 这样这个世界就热闹起来了，人也有了，但是这样创建太累了，神仙也会累的，那怎么办？神仙就想了：我塞进去一团泥巴，随机出来一群人，管他是黑人、白人、黄人，只要是人就成（你看看，神仙都偷懒，何况是我们人），看我们的程序修改，先修改 HumanFactory.java，增加了 createHuman()方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.cbf4life; import java.util.List; import java.util.Random; public class HumanFactory &#123; &#x2F;&#x2F;定一个烤箱，泥巴塞进去，人就出来，这个太先进了public static Human createHuman(Class c)&#123; &#x2F;&#x2F;定义一个类型的人类 Human human&#x3D;null; try &#123; human &#x3D; (Human)Class.forName(c.getName()).newInstance(); &#x2F;&#x2F;产生一个人种 &#125; catch (InstantiationException e) &#123; &#x2F;&#x2F;你要是不说个人种颜色的话，没法烤，要白的黑，你说话了才好烤 System.out.println(&quot;必须指定人种的颜色&quot;); &#125; catch (IllegalAccessException e) &#123; &#x2F;&#x2F;定义的人种有问题，那就烤不出来了，这是... System.out.println(&quot;人种定义错误！&quot;); &#125; catch (ClassNotFoundException e) &#123; &#x2F;&#x2F;你随便说个人种，我到哪里给你制造去？！ System.out.println(&quot;混蛋，你指定的人种找不到！&quot;); &#125; return human; &#125; &#x2F;&#x2F;女娲生气了，把一团泥巴塞到八卦炉，哎产生啥人种就啥人种public static Human createHuman()&#123; Human human&#x3D;null; &#x2F;&#x2F;定义一个类型的人类 &#x2F;&#x2F;首先是获得有多少个实现类，多少个人种 List&lt;Class&gt; concreteHumanList &#x3D; ClassUtils.getAllClassByInterface(Human.class); &#x2F;&#x2F;定义了多少人种 &#x2F;&#x2F;八卦炉自己开始想烧出什么人就什么人 Random random &#x3D; new Random(); int rand &#x3D; random.nextInt(concreteHumanList.size()); human &#x3D; createHuman(concreteHumanList.get(rand)); return human; &#125; &#125; 然后看女娲是如何做的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.cbf4life; &#x2F;*** @author cbf4Life cbf4life@126.com* I&#39;m glad to share my knowledge with you all.* 首先定义女娲，这真是额的神呀*&#x2F;public class NvWa &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;女娲第一次造人，试验性质，少造点，火候不足，缺陷产品 System.out.println(&quot;------------造出的第一批人是这样的：白人-----------------&quot;); Human whiteHuman &#x3D; HumanFactory.createHuman(WhiteHuman.class); whiteHuman.cry(); whiteHuman.laugh(); whiteHuman.talk(); &#x2F;&#x2F;女娲第二次造人，火候加足点，然后又出了个次品，黑人 System.out.println(&quot;\\n\\n------------造出的第二批人是这样的：黑人-----------------&quot;); Human blackHuman &#x3D; HumanFactory.createHuman(BlackHuman.class); blackHuman.cry(); blackHuman.laugh(); blackHuman.talk(); &#x2F;&#x2F;第三批人了，这次火候掌握的正好，黄色人种（不写黄人，免得引起歧义），备注：RB人不属于此列 System.out.println(&quot;\\n\\n------------造出的第三批人是这样的：黄色人种-----------------&quot;); Human yellowHuman &#x3D; HumanFactory.createHuman(YellowHuman.class); yellowHuman.cry(); yellowHuman.laugh(); yellowHuman.talk(); &#x2F;&#x2F;女娲烦躁了，爱是啥人种就是啥人种，烧吧 for(int i&#x3D;0;i&lt;10000000000;i++)&#123; System.out.println(&quot;\\n\\n------------随机产生人种了-----------------&quot; + i); Human human &#x3D; HumanFactory.createHuman(); human.cry(); human.laugh(); human.talk(); &#125; &#125; &#125; 哇，这个世界热闹了！，不过还没有完毕，这个程序你跑不起来，还要有这个类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.cbf4life; import java.io.File; import java.io.IOException; import java.net.URL; import java.util.ArrayList; import java.util.Enumeration; import java.util.List; &#x2F;*** @author cbf4Life cbf4life@126.com I&#39;m glad to share my knowledge with you* all.* *&#x2F;@SuppressWarnings(&quot;all&quot;) public class ClassUtils &#123; &#x2F;&#x2F;给一个接口，返回这个接口的所有实现类public static List&lt;Class&gt; getAllClassByInterface(Class c)&#123; List&lt;Class&gt; returnClassList &#x3D; new ArrayList&lt;Class&gt;(); &#x2F;&#x2F;返回结果 &#x2F;&#x2F;如果不是一个接口，则不做处理 if(c.isInterface())&#123; String packageName &#x3D; c.getPackage().getName(); &#x2F;&#x2F;获得当前的包名 try &#123; List&lt;Class&gt; allClass &#x3D; getClasses(packageName); &#x2F;&#x2F;获得当前包下以及子包下的所有类 &#x2F;&#x2F;判断是否是同一个接口 for(int i&#x3D;0;i&lt;allClass.size();i++)&#123; if(c.isAssignableFrom(allClass.get(i)))&#123; &#x2F;&#x2F;判断是不是一个接口 if(!c.equals(allClass.get(i)))&#123; &#x2F;&#x2F;本身不加进去 returnClassList.add(allClass.get(i)); &#125; &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return returnClassList; &#125; &#x2F;&#x2F;从一个包中查找出所有的类，在jar包中不能查找private static List&lt;Class&gt; getClasses(String packageName) throws ClassNotFoundException, IOException &#123; ClassLoader classLoader &#x3D; Thread.currentThread().getContextClassLoader(); String path &#x3D; packageName.replace(&#39;.&#39;, &#39;&#x2F;&#39;); Enumeration&lt;URL&gt; resources &#x3D; classLoader.getResources(path); List&lt;File&gt; dirs &#x3D; new ArrayList&lt;File&gt;(); while (resources.hasMoreElements()) &#123; URL resource &#x3D; resources.nextElement(); dirs.add(new File(resource.getFile())); &#125; ArrayList&lt;Class&gt; classes &#x3D; new ArrayList&lt;Class&gt;(); for (File directory : dirs) &#123; classes.addAll(findClasses(directory, packageName)); &#125; return classes; &#125; private static List&lt;Class&gt; findClasses(File directory, String packageName) throws ClassNotFoundException &#123; List&lt;Class&gt; classes &#x3D; new ArrayList&lt;Class&gt;(); if (!directory.exists()) &#123; return classes; &#125; File[] files &#x3D; directory.listFiles(); for (File file : files) &#123; if (file.isDirectory()) &#123; assert !file.getName().contains(&quot;.&quot;); classes.addAll(findClasses(file, packageName + &quot;.&quot; + file.getName())); &#125; else if (file.getName().endsWith(&quot;.class&quot;)) &#123; classes.add(Class.forName(packageName + &#39;.&#39; + file.getName().substring(0, file.getName().length() - 6))); &#125; &#125; return classes; &#125; &#125; ​ 告诉你了，这个 ClassUtils 可是个宝，用处可大了去了，可以由一个接口查找到所有的实现类，也可以由父类查找到所有的子类。 我们来总结一下，特别是增加了 createHuman()后，是不是这个工厂的扩展性更好了？你看你要再加一个人种，只要你继续集成 Human 接口成了，然后啥都不用修改就可以生产了，具体产多少，那要八卦炉说了算，简单工厂模式就是这么简单，那我们再引入一个问题：人是有性别的呀，有男有女，你这怎么没区别，别急，这个且听下回分解！​ 工厂方法模式还有一个非常重要的应用，就是延迟始化(Lazy initialization)，什么是延迟始化呢？一个对象初始化完毕后就不释放，等到再次用到得就不用再次初始化了，直接从内存过中拿到就可以了，怎么实现呢，很简单，看例子： 12345678910111213141516171819202122232425262728293031323334353637package com.cbf4life.advance; import java.util.HashMap; &#x2F;*** @author cbf4Life cbf4life@126.com* I&#39;m glad to share my knowledge with you all.*&#x2F;@SuppressWarnings(&quot;all&quot;) public class HumanFactory &#123; &#x2F;&#x2F;定义一个MAP,初始化过的Human对象都放在这里 private static HashMap&lt;String,Human&gt; humans &#x3D; new HashMap&lt;String,Human&gt;(); &#x2F;&#x2F;定一个烤箱，泥巴塞进去，人就出来，这个太先进了public static Human createHuman(Class c)&#123; Human human&#x3D;null; &#x2F;&#x2F;定义一个类型的人类 try &#123; &#x2F;&#x2F;如果MAP中有，则直接从取出，不用初始化了 if(humans.containsKey(c.getSimpleName()))&#123; human &#x3D; humans.get(c.getSimpleName()); &#125;else&#123; human &#x3D; (Human)Class.forName(c.getName()).newInstance(); &#x2F;&#x2F;放到MAP中 humans.put(c.getSimpleName(), human); &#125; &#125; catch (InstantiationException e) &#123; &#x2F;&#x2F;你要是不说个人种颜色的话，没法烤，要白的黑，你说话了才好烤 System.out.println(&quot;必须指定人种的颜色&quot;); &#125; catch (IllegalAccessException e) &#123; &#x2F;&#x2F;一定定义的人种有问题，那就烤不出来了，这是... System.out.println(&quot;人种定义错误！&quot;); &#125; catch (ClassNotFoundException e) &#123; &#x2F;&#x2F;你随便说个人种，我到哪里给你制造去？！ System.out.println(&quot;混蛋，你指定的人种找不到！&quot;); &#125; return human; &#125; 很简单，就加上了上边的if …else部分的代码，这个在类初始化很消耗资源的情况比较实用，比如你要连接硬件，或者是为了初始化一个类需要准备比较多条件（参数），通过这种方式可以很好的减少项目的复杂程度。以上便是工厂方法模式的介绍了","categories":[{"name":"Diary","slug":"Diary","permalink":"http://example.com/categories/Diary/"}],"tags":[{"name":"PS3","slug":"PS3","permalink":"http://example.com/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"http://example.com/tags/Games/"}]},{"title":"关于Layui","slug":"Layui","date":"2021-01-21T11:40:31.000Z","updated":"2021-01-21T11:58:16.926Z","comments":true,"path":"2021/01/21/Layui/","link":"","permalink":"http://example.com/2021/01/21/Layui/","excerpt":"","text":"简介:1layui（谐音：类UI) 是一款采用自身模块规范编写的前端 UI 框架，遵循原生 HTML&#x2F;CSS&#x2F;JS 的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到 API 的每一处细节都经过精心雕琢，非常适合界面的快速开发。layui 首个版本发布于 2016 年金秋，她区别于那些基于 MVVM 底层的 UI 框架，却并非逆道而行，而是信奉返璞归真之道。准确地说，她更多是为后端程序员量身定做，你无需涉足各种前端工具的复杂配置，只需面对浏览器本身，让一切你所需要的元素与交互，从这里信手拈来。 下载: 1、在官网上下载 官网地址:https://www.layui.com/ ​ 下载后的目录如下: 123456789101112├─css &#x2F;&#x2F;css目录 │ │─modules &#x2F;&#x2F;模块css目录（一般如果模块相对较大，会单独提取，比如下面三个：） │ │ ├─laydate │ │ ├─layer │ │ └─layim │ └─layui.css &#x2F;&#x2F;核心样式文件 ├─font &#x2F;&#x2F;字体图标目录 ├─images &#x2F;&#x2F;图片资源目录（目前只有layim和编辑器用到的GIF表情） │─lay &#x2F;&#x2F;模块核心目录 │ └─modules &#x2F;&#x2F;各模块组件 │─layui.js &#x2F;&#x2F;基础核心库 └─layui.all.js &#x2F;&#x2F;包含layui.js和所有模块的合并文件 2、Git 仓库下载 可以通过 GitHub 或 码云 得到 layui 的完整开发包，以便于你进行二次开发，或者 Fork layui 为我们贡献方案 GitHub:https://github.com/sentsin/layui/ 码云:https://gitee.com/sentsin/layui/ 3、npm 安装，在你需要下载的文件下打开Git Bash Here,在里边输入以下代码 1npm i layui-src 这样Layui就下载好了","categories":[{"name":"Diary","slug":"Diary","permalink":"http://example.com/categories/Diary/"}],"tags":[{"name":"PS3","slug":"PS3","permalink":"http://example.com/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"http://example.com/tags/Games/"}]},{"title":"逻辑篇(二)","slug":"逻辑篇-二","date":"2021-01-12T08:04:03.000Z","updated":"2021-01-12T08:29:54.470Z","comments":true,"path":"2021/01/12/逻辑篇-二/","link":"","permalink":"http://example.com/2021/01/12/%E9%80%BB%E8%BE%91%E7%AF%87-%E4%BA%8C/","excerpt":"","text":"1、在某城，居民们的头发数目是随机的,假设以下关于居民的断定都是事实:1．没有两个居民的头发数量正好一样多。2．没有一个居民的头发大于517根。3．居民的总数比任何一个居民的头发数还要多。那么,该城居民的总数最多不可能超过多少人?A、517 B、518 C.519 D、520 1234 根据题意，每个居民头发数量都不一样，而且最多是517根。因为居民总数比任一个头发数都要多，为了让居民总数尽可能大，那最大的头发数应取517。 也就是至少要518人，这时每个人的头发数量是：0、1、2、...、517。而且，也不能超过518人，否则最大的头发数就不是517了。所以居民总数最多不超过518人。 2、在非洲某个地区有两个奇怪的部落，第一个部落的人每逢周一、三、五就说谎，另一个部落的人每逢周二、四、六就说谎，在其他的日子他们都说实话。有一天，一位探险家来到这个奇怪的地区，见到了两个人，他们分别属于这两个部落。探险家向他们询问今天是星期几,两个人并没有明确告诉他，都只是说了同一句话:“前天是我说谎的日子。”那么，这一天究竟是星期几呢? A、星期一 B、星期三 C、星期六 D、星期日 1234567用假设法来解决。假设这两人为AB，A在一三五为假，B在二四六为假，AB在星期日都为真。如果AB都为真，那只可能是星期日，那前天就是五，这一天B说真话，跟“我说谎”矛盾，所以假设不对。如果A真B假，那只能是二四六，那前天就是日二四，这一天A都为真，跟“我说谎”矛盾，所以假设不对。如果A假B真，那只能是一三五。如果是一，那前天是六，这一天A为真，B为假，符合条件。如果是三五，那前天是一三，B都为真，跟“我说谎”矛盾，假设不对。如果AB都为假，不存在这一天，假设不对。所以，只有星期一符合条件。 海滩上有20只萌妹纸，其中:(1) 有的人会游泳;(2）有的人不会游泳;(3) 年纪最小的妹纸不会游泳。以上三句描述只有一句是对的。海滩上到底有几个人会游泳呢?A、0 B、1 C、19 D、20 1234 认为3描述的是对的只有一人不会游泳. 1 2 都无法判断数字 但也同时承认有一个不会游泳 2 有点人不会游泳就成立. 以上3句就不成立. 3绝对是错的.有点人会游泳和有的人不会游泳 在以上3句的支持下 只有一个是对的,就是说这两个绝对的矛盾,单看句子就会认为有会的有不会的但他不是一句,而是两个不同的判定,在以上3句的支持下可以解读为会游泳的和不会游泳的两类,分析3有个不会游泳的小孩是错的,那就是说全会游泳是对的.我认为有20个人你会游泳. 村子里有两种人:一种是只说真话的老实人,一种是只说假话的骗子。这天，我来到村子，想知道这个村子有几个骗子。中午吃饭的时候，全村人都围坐在一个大大的圆餐桌旁。我向每个人都问了一个同样的问题:“你左边的那个人是不是骗子?每个人都回答:“是。”我问村支书:“村子一共有多少人?””，村支书说有25人。午餐后，我向村里的会计了解更多情况,会计说:“村里一共有36人，村支书是骗子。”请问，这个村子一共有多少个骗子?A、12 B、13 C、18 D、25 12345答案是C，即18个骗子。所有人围在一起，都说左边的人是骗子，所以不可能两个骗子或老实人挨在一起，一定是交叉来坐，而且人数不能是单数（如果是单数就一定出现两骗子或两老实人挨在一起）。村支书说有25人，是单数，所以村支书是骗子。因为骗子不会说骗子是骗子，所以会计是老实人。所以村子有36人，一半是骗子，所以18人是骗子。 有一个大门的门铃很特别，它有六个按钮，其中五个按钮是假的，只有一个是真的。只要按错(哪怕同时按)门铃系统就会停止工作。在大门的按钮旁边贴有一张告示，上面写着:”A在B左边;B是C的右边第三个;C在D的右边;D紧靠着E;E和A中间隔一个按钮。来者请按没有提到的那个按钮。”请问，哪个是门铃的真正按钮?A、左1 B、左2 C、左3 D、左4 E、左5 F、左6 1不会 据说亚里士多德学院门口竖着一块牌子,上面写着:“不懂逻辑者不得入内”。一天你到访学院却被拦在门外,门卫说:“牌子上的规矩会被严格执行,请你看清楚。”这时,你觉得以下哪项最可能让你进去学院?A、告诉门卫你是学院院长请来研究学术的。B、告诉门卫你不懂逻辑但也可以进去。C、告诉门卫你懂逻辑所以不能不放你进去。D、告诉门卫你懂逻辑，然后微笑看着门卫。 12345678910111213答案选A由题干2113“不懂逻辑者不得5261入内”可知“4102入内就一定懂逻辑”我们用1653数学模版式表示：入内 →权 懂逻辑已知 A → B，根据逻辑推理学可知：若A真则B真，若B假则A假。若B真，A则真假不定。举个例子说：如果天下雨（A），那么地就滑（B）。那么我们会得到以下结论：下雨→ 地滑 ；或者是：地不滑→ 天没下雨但是我们不能得到：地滑了，天就一定下雨（地滑→ 下雨）×比如说天没下雨，我倒些水去，地一样滑，所以地滑不能得到下雨。所以：（地滑→ 下雨）是错误的同样道理，现在我们从题干中知道一群人“懂逻辑”了，却不能推出“入内”。所以答案应该是“不一定入内”，也就是说“可能入内”，也“可能不入内”。因此所有肯定的说法都是错误的，即BCD为假。所以：答案选A 张老师的班里有60个学生，男女各占一半。有40个学生喜欢数学,有50个学生喜欢语文。这表明可能会有:A.20个男生喜欢数学而不喜欢语文B.20个喜欢语文的男生不喜欢数学C.30个喜欢语文的女生不喜欢数学D.30个喜欢数学的男生只有10个喜欢语文 1A选项是错的，因为已有50个学生喜欢语文了，只有10个学生不喜欢语文而非20个，所有A应排除；C选项也属此类，因为只能有20个学生不喜欢数学而非30个，所以C选项也应排除；D选项30个喜欢数学的男生，只有10个喜欢语文也是错误的，这样至少有20个学生不喜欢语文了，与陈述亦有矛盾，故C也应排除；只有B选项是对的，20个喜欢语文的学生不喜欢数学，因为数学可以有20人不喜欢的。故本题的正确答案为B 只要诊断准确并且救治及时,那么这个病人就不会死亡。现在这个病人不幸死亡了。如果上述断定是真的，下面哪项也一定是真的()A．对这个病人诊断不准确,但救治及时B.对这个病人诊断是准确的,但救治不及时C.如果这个病人死亡的原因是诊断不准确,那么救治不及时不会是原因D.如果这个病人的诊断是准确的,那么,造成死亡的原因一定是救治不及时 1由“只要诊断准确并且救治及时，这个病人就不会死亡”和“现在这个病人不幸死亡了”，可得：诊断不准确或者救治不及时。从这个断定出发，运用选言推理的否定肯定式，可以推出如果诊断准确，则救治不及时。 任何企业,只有诚信,才能发展。以下各项都符合题干的条件,除了:A.任何企业,如果得到发展，则一定诚信。B.任何企业,不可能发展但不诚信。C.任何企业,除非诚信,否则不能发展。D.任何企业,或者诚信,或者不发展。E.任何企业，不可能诚信但不发展。 1A、B、C、D都是题干的变形表达，表达的意思都是一样的，把“诚信”作为“发展”的必要条件。所以选E。","categories":[],"tags":[]},{"title":"个人博客","slug":"个人博客","date":"2020-12-30T05:53:11.000Z","updated":"2021-01-06T10:57:48.884Z","comments":true,"path":"2020/12/30/个人博客/","link":"","permalink":"http://example.com/2020/12/30/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"余文","slug":"余文","date":"2020-12-11T02:35:05.000Z","updated":"2021-01-06T10:57:48.886Z","comments":true,"path":"2020/12/11/余文/","link":"","permalink":"http://example.com/2020/12/11/%E4%BD%99%E6%96%87/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"Diary","slug":"Diary","permalink":"http://example.com/categories/Diary/"}],"tags":[{"name":"PS3","slug":"PS3","permalink":"http://example.com/tags/PS3/"},{"name":"Games","slug":"Games","permalink":"http://example.com/tags/Games/"}]}